#!/system/bin/sh
# Terminal Magisk Mod Template
# by veez21 @ xda-developers


# Magisk Module ID **
# > ENTER MAGISK MODULE ID HERE
ID="terminal_debloater"

#=========================== Check root
_name=$0; _name=${_name##*/}
id | grep -q root
[ $? -ne 0 ] && { echo "$ID needs to be in a root shell!"; echo "type 'su' then '$_name'"; exit 1; }

#=========================== Set Log Files
mount -o remount,rw /cache 2>/dev/null
mount -o rw,remount /cache 2>/dev/null
# > Logs should go in this file
LOG=/cache/${ID}.log
oldLOG=/cache/${ID}-old.log
# > Verbose output goes here
VERLOG=/cache/${ID}-verbose.log
oldVERLOG=/cache/${ID}-verbose-old.log

#=========================== Start Logging verbosely
mv -f $VERLOG $oldVERLOG 2>/dev/null; mv -f $LOG $oldLOG 2>/dev/null
set -x 2>$VERLOG

#=========================== Determine if A/B OTA device
if [ -d /system_root ]; then
	isABDevice=true
	SYSTEM=/system_root/system
	SYSTEM2=/system
else
	isABDevice=false
	SYSTEM=/system
	SYSTEM2=/system
fi

#=========================== Set Busybox (Used by Magisk) up
# > Do not touch!
set_busybox() {
	if [ -x "$1" ]; then
		for i in $(${1} --list); do
			if [ "$i" != 'echo' ]; then
				alias "$i"="${1} $i" 2>>$LOG >>$LOG
			fi
		done
		_busybox=true
		_bb=$1
	fi
}
_busybox=false
if [ -d /sbin/.core/busybox ]; then
	PATH=$PATH:/sbin/.core/busybox
	_bb=/sbin/.core/busybox/busybox
	_busybox=true
elif [ ! -x $SYSTEM/xbin/busybox ]; then
	set_busybox /data/magisk/busybox
	set_busybox /data/adb/magisk/busybox
else
	alias busybox=""
fi
if [ -x $SYSTEM/xbin/busybox ]; then
	_bb=$SYSTEM/xbin/busybox
elif [ -x $SYSTEM/bin/busybox ]; then
	_bb=$SYSTEM/bin/busybox
elif [ $_busybox ]; then
	true
else
	echo "! Busybox not detected.."
	echo "Please install one (@osm0sis' busybox recommended)"
	false
fi
[ $? -ne 0 ] && exit $?
alias echo='echo -e'
[ -n "$LOGNAME" ] && alias clear='echo'
_bbname=$(busybox | head -n1)
_bbname=${_bbname%'('*}
BBok=true
if [ "$_bbname" == "" ]; then
	_bbname="BusyBox not found!"
	BBok=false
fi

#=========================== Default Functions and Variables

# Import util_functions.sh
[ -f /data/adb/magisk/util_functions.sh ] && . /data/adb/magisk/util_functions.sh || exit 1

# Magisk Mod Directory
MOUNTPATH=/magisk
if [ ! -d $MOUNTPATH ]; then
	if [ -d /sbin/.core/img ]; then
		MOUNTPATH=/sbin/.core/img
	fi
fi
MODDIR="$MOUNTPATH/$ID"
if [ ! -d $MODDIR ]; then
	if [ -d /sbin/.core/img/$ID ]; then
		MODDIR=/sbin/.core/img/$ID
	else
		echo "Module not detected!"
		exit 1
	fi
fi

# Device Info
# BRAND MODEL DEVICE API ABI ABI2 ABILONG ARCH
BRAND=$(getprop ro.product.brand)
MODEL=$(getprop ro.product.model)
DEVICE=$(getprop ro.product.device)
ROM=$(getprop ro.build.display.id)
api_level_arch_detect

# Version Number
VER=$(grep_prop version $MODDIR/module.prop)
# Version Code
REL=$(grep_prop versionCode $MODDIR/module.prop)
# Author
AUTHOR=$(grep_prop author $MODDIR/module.prop)
# Mod Name/Title
MODTITLE=$(grep_prop name $MODDIR/module.prop)

# Colors
G='\e[01;32m'		# GREEN TEXT
R='\e[01;31m'		# RED TEXT
Y='\e[01;33m'		# YELLOW TEXT
B='\e[01;34m'		# BLUE TEXT
V='\e[01;35m'		# VIOLET TEXT
Bl='\e[01;30m'		# BLACK TEXT
C='\e[01;36m'		# CYAN TEXT
W='\e[01;37m'		# WHITE TEXT
BGBL='\e[1;30;47m'	# Background W Text Bl
N='\e[0m'			# How to use (example): echo "${G}example${N}"
loadBar=' '			# Load UI
# Remove colors if -nc or in ADB Shell
[ -n "$1" -a "$1" == "-nc" ] && shift && NC=true
[ "$NC" -o -n "$LOGNAME" ] && {
	G=''; R=''; Y=''; B=''; V=''; Bl=''; C=''; W=''; N=''; BGBL=''; loadBar='=';
}

# Divider (based on $MODTITLE, $VER, and $REL characters)
character_no=$(echo $MODTITLE $VER $REL | tr " " '_' | wc -c)
div="${Bl}$(printf '%*s' "${character_no}" '' | tr " " "=")${N}"

# Title Div :3
title_div() {
	no=$(echo $@ | wc -c)
	extdiv=$((no-character_no))
	echo "${W}$@${N} ${Bl}$(printf '%*s' "$extdiv" '' | tr " " "=")${N}"
}

# set_file_prop <property> <value> <prop.file>
set_file_prop() {
	sed -i "s/${1}=.*/${1}=${2}/g" $3
}

# https://github.com/fearside/ProgressBar
ProgressBar() {
# Process data
	_progress=$(((${1}*100/${2}*100)/100))
	_done=$(((${_progress}*4)/10))
	_left=$((40-$_done))
# Build progressbar string lengths
	_done=$(printf "%${_done}s")
	_left=$(printf "%${_left}s")

# 1.2 Build progressbar strings and print the ProgressBar line
# 1.2.1 Output example:
# 1.2.1.1 Progress : [########################################] 100%
printf "\rProgress : ${BGBL}|${N}${_done// /${BGBL}$loadBar${N}}${_left// / }${BGBL}|${N} ${_progress}%%"
}

# "cmd & spinner [message]"
spinner() {
	PID=$!
	h=0; anim='-\|/';
	while [ -d /proc/$PID ]; do
		h=$(((h+1)%4))
		sleep 0.02
		printf "\rLoading [${anim:$h:1}]"
	done
}
test_connection() {
	echo -n "Testing internet connection "
	ping -q -c 1 -W 1 google.com >/dev/null 2>/dev/null && echo "- OK" || { echo "Error"; false; }
}
# Log files will be uploaded to termbin.com
upload_logs() {
	$BBok && {
		test_connection
		[ $? -ne 0 ] && exit
		verUp=none; oldverUp=none; logUp=none; oldlogUp=none;
		echo "Uploading logs"
		[ -s $VERLOG ] && verUp=$(cat $VERLOG | nc termbin.com 9999)
		[ -s $oldVERLOG ] && oldverUp=$(cat $oldVERLOG | nc termbin.com 9999)
		[ -s $LOG ] && logUp=$(cat $LOG | nc termbin.com 9999)
		[ -s $oldLOG ] && oldlogUp=$(cat $oldLOG | nc termbin.com 9999)
		echo -n "Link: "
		echo "$MODEL ($DEVICE) API $API\n$ROM\n$ID\n
		O_Verbose: $oldverUp
		Verbose:   $verUp
	
		O_Log: $oldlogUp
		Log:   $logUp" | nc termbin.com 9999
	} || echo "Busybox not found!"
	exit
}

# Heading
mod_head() {
	clear
	echo "$div"
	echo "${W}$MODTITLE $VER${N}(${Bl}$REL${N})"
	echo "by ${W}$AUTHOR${N}"
	echo "$div"
	echo "${W}$_bbname${N}"
	echo "${Bl}$_bb${N}"
	echo "$div"
	[ -s $LOG ] && echo "Enter ${W}logs${N} to upload logs" && echo $div
}

#=========================== Main
# > You can start your MOD here.
# > You can add functions, variables & etc.
# > Rather than editing the default vars above.

help_me() {
	cat << EOF
$MODTITLE $VER($REL)
by $AUTHOR
	
Usage: $_name
   or: $_name [options]...
   
Options:
    -nc                              removes ANSI escape codes
    -l [app|priv-app|vendor]         list system apps
    -d [app label|app folder name]   uninstall apps (use $_name -d -h)
    -i [file]                        import config from file
    -e [file]                        export current settings
    -h                               show this message
EOF
exit
}

show_rein=false
[ -n "$(find $MODDIR$SYSTEM2/app -name ".replace" -type f)" ] &&  show_rein=true
[ -n "$(find $MODDIR$SYSTEM2/priv-app -name ".replace" -type f)" ] &&  show_rein=true

use_aapt=false
[[ "$(which aapt)" ]] && use_aapt=true
export PATH=$MODDIR:$PATH
import_file=/cache/import-debloat.txt
exclude_file=$MODDIR/exclude.list

get_app_name() {
	if [ $use_aapt ]; then
		app_name=$(aapt dump badging $1/${name[$2]}.apk 2>$LOG | grep 'application-label:' 2>/dev/null)
		if [ $? -gt 0 ]; then
			app_name[$2]=${name[$2]}
			return
		fi
		app_name=${app_name#*:}
		app_name[$2]=$(echo $app_name | tr ' ' '_' | tr -d "'")
		app_label=$(aapt dump badging $1/${name[$2]}.apk | grep package | head -n1)
		app_label=${app_label#*"'"}
		app_label=${app_label%%"'"*}
		app_label[$2]=$app_label
	else
		app_name[$2]=${name[$2]}
	fi
}

list_s-app() {
	app_name=(); listapp=()
	x=1
	type=$1
	sapp=($(ls $SYSTEM/$type))
	for i in ${sapp[@]}; do
		ProgressBar $x ${#sapp[@]}
		listapp[$x]=$SYSTEM2/$type/$i
		if [[ ! -d $MODDIR${listapp[$x]} ]]; then
			if ! grep -q /${i} $exclude_file; then
				name[$x]=${i}
				apk_name[$x]="${i}.apk"
				get_app_name ${listapp[$x]} $x
				x=$((x+1))
			fi
		fi
	done
}

list_unin_app() {
	c=1
	if [ -d $SYSTEM/app ] && [ -d $MODDIR$SYSTEM2/app ]; then
		for i in $(ls $MODDIR$SYSTEM2/app); do
			unin_app[$c]=$MODDIR$SYSTEM2/app/$i
			name_unin[$c]=$(cat $MODDIR$SYSTEM2/app/$i/.replace)
			if [ $? -gt 0 ] || [ -z ${name_unin[$c]} ] || [[ ! $(cat $MODDIR$SYSTEM2/app/$i/.replace) ]]; then
				name_unin[$c]=$i
			fi
			echo " $c - ${W}${name_unin[$c]}${N}" | tr '_' ' '
			c=$((c+1))
		done
	fi
	if [ -d $SYSTEM/priv-app ] && [ -d $MODDIR$SYSTEM2/priv-app ]; then
		for i in $(ls $MODDIR$SYSTEM2/priv-app); do
			unin_app[$c]=$MODDIR$SYSTEM2/priv-app/$i
			name_unin[$c]=$(cat $MODDIR$SYSTEM2/priv-app/$i/.replace)
			if [ $? -gt 0 ] || [ -z ${name_unin[$c]} ] || [[ ! $(cat $MODDIR$SYSTEM2/priv-app/$i/.replace) ]]; then
				name_unin[$c]=$i
			fi
			echo " $c - ${W}${name_unin[$c]}${N}" | tr '_' ' '
			c=$((c+1))
		done
	fi
}

import_list() {
	[ "$1" ] && import_file=$1
	if [ -f $import_file ] && (grep -q "$MODDIR" $import_file); then
		c=1
		import_apps=($(cat $import_file))
		for i in ${import_apps[@]}; do
			name[$c]=${i##*/}
			sys_dir=${i#*${MODDIR}}
			get_app_name $sys_dir $c
			mktouch $i/.replace ${app_name[$c]}
			echo "${W}${app_name[$c]}${N} - Imported"
			c=$((c+1))
		done
	else
		echo "Invalid file"
	fi
}

export_list() {
	[ "$1" ] && import_file=$1
	mktouch $import_file
	for i in $(find $MODDIR/system -name ".replace" -type f); do
		echo ${i%/*} >> $import_file
		echo "$(cat $i) - Exported"
	done
}

menu_list_system_app() {
	clear
	list_s-app app 2>>$LOG
	clear
	echo "$div"
	title_div "System Apps"
	echo "$div"
	echo ""
	c=1
	for i in $(seq 1 $((${#app_name[@]}-1))); do
		echo " $c - $(echo ${W}${app_name[$i]}${N} | tr '_' ' ')"
		c=$((c+1))
	done
	echo ""
	echo " ${Bl}To uninstall multiple apps, enter multiple numbers. Example:${N} \"1 $(echo ${#app_name[$((${#app_name[@]}/3))]}) $(echo ${#app_name[$((${#app_name[@]}/2))]})\""
	echo " x - ${Bl}Back to Menu${N}"
	echo " 0 - ${Bl}Exit${N}"
	echo "$div"
	echo -n "[CHOICE]: "
	read app
	[ "$app" == "x" ] && menu
	for i in $app; do
		if [ "$i" -gt "${#listapp[@]}" ] || [ "$i" -lt "0" ] || [ "$i" == "" ] || [ -n "$(echo $i | tr -d '0-9')" ] ; then
			echo "$i - Invalid"; false
		elif [ "$i" == "0" ]; then
			exit
		else
			echo "Uninstalling ${R}${app_name[$i]}${N}" | tr '_' ' '
			sleep 1
			mktouch $MODDIR${listapp[$i]}/.replace ${app_name[$i]}
			if [[ -d "/data/app/${app_label[$i]}-*" ]]; then
				echo -n " - APK stored in /data, delete? < y | n > " 
				read del_apk; [ "$del_apk" == "y" ] && {
					data_apkdir=$(echo /data/app/${app_label[$i]}-*)
					if [ -d "${data_apkdir}" ]; then
						rm -rf ${data_apkdir} 2>/dev/null
						echo " - deleted"
					fi
				} || echo " - not deleted"
			fi
		fi
	done
	echo "Reboot to apply changes"
	echo -n "Return to menu? < y | n >: "
	read mchoice
	[ "$mchoice" == "y" ] && menu || exit
}

menu_list_system_priv-app() {
	clear
	list_s-app priv-app 2>>$LOG
	clear
	echo "$div"
	title_div "System Priv-Apps"
	echo "$div"
	echo ""
	c=1
	for i in $(seq 1 $((${#app_name[@]}-1))); do
		echo " $c - $(echo ${W}${app_name[$i]}${N} | tr '_' ' ')"
		c=$((c+1))
	done
	echo ""
	echo " ${Bl}To uninstall multiple apps, enter multiple numbers. Example:${N} \"1 $(echo ${#app_name[$((${#app_name[@]}/3))]}) $(echo ${#app_name[$((${#app_name[@]}/2))]})\""
	echo " x - ${Bl}Back to Menu${N}"
	echo " 0 - ${Bl}Exit${N}"
	echo "$div"
	echo -n "[CHOICE]: "
	read privapp
	[ "$privapp" == "x" ] && menu
	for i in $privapp; do
		if [ "$i" -gt "${#listapp[@]}" ] || [ "$i" -lt "0" ] || [ "$i" == "" ] || [ -n "$(echo $i | tr -d '0-9')" ] ; then
			echo "$i - Invalid"; false
		elif [ "$i" == "0" ]; then
			exit
		else
			echo "Uninstalling ${R}${app_name[$i]}${N}" | tr '_' ' '
			sleep 1
			mktouch $MODDIR${listapp[$i]}/.replace ${app_name[$i]}
			if [[ -d "/data/app/${app_label[$i]}-*" ]]; then
				echo -n " - APK stored in /data, delete? < y | n > " 
				read del_apk; [ "$del_apk" == "y" ] && {
					data_apkdir=$(echo /data/app/${app_label[$i]}-*)
					if [ -d "${data_apkdir}" ]; then
						rm -rf ${data_apkdir} 2>/dev/null
						echo " - deleted"
					fi
				} || echo " - not deleted"
			fi
		fi
	done
	echo "Reboot to apply changes"
	echo -n "Return to menu? < y | n >: "
	read mchoice
	[ "$mchoice" == "y" ] && menu || exit
}

menu_list_vendor_app() {
	clear
	list_s-app vendor/app 2>>$LOG
	clear
    echo "$div"
	title_div "Vendor Apps"
	echo "$div"
	echo ""
	c=1
	for i in $(seq 1 $((${#app_name[@]}-1))); do
		echo " $c - $(echo ${W}${app_name[$i]}${N} | tr '_' ' ')"
		c=$((c+1))
	done
	echo ""
	echo " ${Bl}To uninstall multiple apps, enter multiple numbers. Example:${N} \"1 $(echo ${#app_name[$((${#app_name[@]}/3))]}) $(echo ${#app_name[$((${#app_name[@]}/2))]})\""
	echo " x - ${Bl}Back to Menu${N}"
	echo " 0 - ${Bl}Exit${N}"
	echo "$div"
	echo -n "[CHOICE]: "
	read vapp
	[ "$vapp" == "x" ] && menu
	for i in $app; do
		if [ "$i" -gt "${#listapp[@]}" ] || [ "$i" -lt "0" ] || [ "$i" == "" ] || [ -n "$(echo $i | tr -d '0-9')" ] ; then
			echo "$i - Invalid"; false
		elif [ "$i" == "0" ]; then
			exit
		else
			echo "Uninstalling ${R}${app_name[$i]}${N}" | tr '_' ' '
			sleep 1
			mktouch $MODDIR${listapp[$i]}/.replace ${app_name[$i]}
			if [[ -d "/data/app/${app_label[$i]}-*" ]]; then
				echo -n " - APK stored in /data, delete? < y | n > " 
				read del_apk; [ "$del_apk" == "y" ] && {
					data_apkdir=$(echo /data/app/${app_label[$i]}-*)
					if [ -d "${data_apkdir}" ]; then
						rm -rf ${data_apkdir} 2>/dev/null
						echo " - deleted"
					fi
				} || echo " - not deleted"
			fi
		fi
	done
	echo "Reboot to apply changes"
	echo -n "Return to menu? < y | n >: "
	read mchoice
	[ "$mchoice" == "y" ] && menu || exit
}

menu_list_unin_app() {
	clear
	echo "$div"
	title_div "Reinstall"
	echo " You can also just delete your selected
 folders in $MODDIR$SYSTEM2/app or priv-app."
	echo " The apps debloated were reset
 to their factory version."
	echo "$div"
	echo ""
	list_unin_app
	echo ""
	echo " ${Bl}To reinstall multiple apps, enter multiple numbers. Example:${N} \"1 $(echo ${#name_unin[$((${#name_unin[@]}/3))]}) $(echo ${#name_unin[$((${#name_unin[@]}/2))]})\""
	echo " x - ${Bl}Back to Menu${N}"
	echo " 0 - ${Bl}Exit${N}"
	echo ""
	echo -n "[CHOICE]: "
	read rein
	[ "$rein" == "x" ] && menu
	for i in $rein; do
		if [ "$i" -gt ${#name_unin[@]} ] || [ "$i" -lt 0 ] || [ "$i" == "" ] || [ -n "$(echo $i | tr -d '0-9')" ] ; then
			echo "Invalid"; false
		elif [ "$i" == "0" ]; then
			exit
		else
			echo "Reinstalling ${G}${name_unin[$i]}${N}" | tr '_' ' '
			sleep 1
			rm -rf ${unin_app[$i]}
		fi
	done
	echo "Reboot to apply changes"
	echo -n "Return to menu? < y | n >: "
	read mchoice
	app_name=()
	[ "$mchoice" == "y" ] && menu || exit
}

menu() {
	mod_head
	echo ""
	[ -d $SYSTEM/app ] && echo " 1 - ${W}System Apps${N}"
	[ -d $SYSTEM/priv-app ] && echo " 2 - ${W}System Priv-Apps${N}"
	[ -d $SYSTEM/vendor/app ] && echo " 3 - ${W}Vendor Apps${N}"
	$show_rein && {
		echo " 4 - ${W}Reinstall Uninstalled Apps${N}"
		echo " e - ${W}Export Config${N}"
	}
	[ -f $import_file ] && echo " i - ${W}Import Config ($import_file)"
	echo " d - ${C}Donate${N}"
	echo " 0 - ${Bl}Exit${N}"
	echo ""
	echo -n "[CHOICE]: "
	read choice
	if [ "$choice" == "1" ]; then
		if [ -d $SYSTEM/app ]; then
			menu_list_system_app
		else
			abort Invalid
		fi
	elif [ "$choice" == 2 ]; then
		if [ -d $SYSTEM/priv-app ]; then
			menu_list_system_priv-app
		else
			abort Invalid
		fi
	elif [ "$choice" == 3 ]; then
		if [ -d $SYSTEM/vendor/app ]; then
			menu_list_vendor_app
		else
			abort Invalid
		fi
	elif [ "$choice" == 4 ]; then
		if $show_rein; then
			menu_list_unin_app
		else
			abort "Invalid"
		fi
	elif [ "$choice" == "e" ]; then
		if $show_rein; then
			clear
			echo "Exporting to ${W}$import_file...${N}"
			sleep 0.4
			clear
			export_list
			echo "Done"
			echo -n "Return to menu? < y | n >: "
			read mchoice
			[ "$mchoice" == "y" ] && menu || exit
		else
			abort "Invalid"
		fi
	elif [ "$choice" == "i" ]; then
		if [ -f $import_file ]; then
			clear
			echo "Importing from ${W}$import_file...${N}"
			sleep 0.4
			import_list
			echo "Done"
			echo -n "Return to menu? < y | n >: "
			read mchoice
			[ "$mchoice" == "y" ] && menu || exit
		else
			abort "Invalid"
		fi

	elif [ "$choice" == "d" -o "$choice" == "D" ]; then
		am start https://paypal.me/veez21 >/dev/null
	elif [ "$choice" == "logs" ]; then
		upload_logs
	elif [ "$choice" == "0" ]; then
		exit
	else abort Invalid
	fi
}

case "$1" in
	-i) shift
		[ -s "$1" ] && { import_list $1; exit; } || abort "Invalid file!";;
	-e) shift
		[ -f "$1" ] && abort "File exists!" || { export_list "$1"; exit; };;
	-l) shift
		[ ! "$1" ] && abort "$(help_me)"
		if [ "$1" == "app" ]; then
			list_s-app app 2>>$LOG
		elif [ "$1" == "priv-app" ]; then
			list_s-app priv-app 2>>$LOG
		elif [ "$1" == "vendor" ]; then
			list_s-app vendor/app 2>>$LOG
		else
			abort "$(help_me)"
		fi
		c=1
		echo
		for i in ${!app_name[@]}; do
			[ ! "${app_label[$i]}" ] && app_label[$i]="null"
			title_div "App $i"
			echo "Name\t: $(echo ${app_name[$i]} | tr '_' ' ')\nLabel\t: ${app_label[$i]}\nDirectory\t: $(echo ${listapp[$i]} | sed 's/.*\/system\///g')" | expand -t 10
			c=$((c+1))
		done; exit;;
	-d) shift
		[ ! "$1" ] && help_me
		[ "$1" == "-h" ] && {
			echo "$_name -d [system app label/s | system app folder/s]\ne.g. \"$_name -d com.google.android.youtube com.android.terminal Velvet LatinIME\"\n"
			echo "To see the list of system apps and its info (its folder name or app label \nin this situation) use \"$_name -l\" "
			exit
		}
		for i in "$@"; do
			d_app_label=$(dumpsys package $i | grep "path:")
			[ $? -gt 0 ] && app_dir=$(find $SYSTEM/app $SYSTEM/priv-app $SYSTEM/vendor/app -name $i -type d) || app_dir=$(echo $d_app_label | sed 's/.*path: //;s/\(.*\)\/.*/\1/')
			[ ! "$app_dir" ] && { echo "$i doesn't exist in $SYSTEM"; ok=false; continue; } || {
				[ $(echo $app_dir | grep "/system") ] && {
					ok=true
				} || {
					echo "$i is not a system app"
					ok=false
					continue
				}
			}
			[ -f $MODDIR$app_dir/.replace ] && echo "$i already uninstalled" && continue
			echo "$i found in $app_dir"
			name[0]=${app_dir##*/}; get_app_name $app_dir 0 2>$LOG
			echo "Uninstalling ${app_name[0]}" | tr '_' ' '
			mktouch $MODDIR$app_dir/.replace ${app_name[0]}
			if [[ -d "/data/app/${app_label[$i]}-*" ]]; then
				echo -n " - APK stored in /data, delete? < y | n > " 
				read del_apk; [ "$del_apk" == "y" ] && {
					data_apkdir=$(echo /data/app/${app_label[0]}-*)
					if [ -d "${data_apkdir}" ]; then
						rm -rf ${data_apkdir} 2>/dev/null
						echo " - deleted"
					fi
				} || echo " - not deleted"
			fi
		done
		$ok || abort "error: Use \"$_name -d -h\" for help"
		exit;;
	-h|--help) help_me;;
esac

menu
exit $?
